// js中的闭包的含义。
// 深入理解javascript原型和闭包（完结），https://www.cnblogs.com/wangfupeng1988/p/3977924.html

// 需要记住闭包的两种使用情况：
// 函数作为返回值，函数作为参数传递。
// 除了结合着作用域之外，还需要结合着执行上下文栈来说一下。

// 1 函数作为返回值
// ---全局作用域---
function fn() {
    var max = 100;
    // ---fn作用域---
    return function bar(x) {
        if (x > max) {
            console.log(x);
        }
        // ---bar作用域---
    };
}

console.log("test");
var f1 = fn(),
    max = 100;
f1(15);

// 我们提到过当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。
// 但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。
// 这就是需要理解闭包的核心内容。

// 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。
// 此时全局上下文环境是活动状态。其中的max是undefined。

// 第二步，执行第23行代码(var f1 = fn();)时，调用fn()。
// 产生fn()执行上下文环境，压栈，并设置为活动状态。
// 此时的fn()执行上下文环境中，max的状态为，被定义为10。

// 第三步，执行完第23行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。
// 注意，重点来了：因为执行fn()时，返回的是一个【函数】。
// 函数的特别之处在于可以创建一个独立的作用域。
// 而正巧合的是，返回的这个函数体中，还有一个自由变量max，要引用fn作用域下的fn()上下文环境中的max。
// 【所以，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。】
// 因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。
// 即，执行到第24行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。
// 另外，执行完第24行，全局上下文环境中的max被赋值为100。

// 第四步，执行到第25行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。
// 执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。
// 这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在于栈中。
// 因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。
// 使用闭包会增加内容开销，现在很明显了吧！

// 第五步，执行完25行就是上下文环境的销毁过程，这里就不再赘述了。
// 【闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！】
// 另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。
// 所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。
// 否则，到时候出了BUG你都不知道为什么，因为这些BUG可能完全在你的知识范围之外。


// 我的理解，闭包有点儿类似于类对象的引用，再最后一次引用被被使用完之前，其不能被销毁。否则对象将找不到其执行时所需的数据、方法。
// 以上内容的方法的一个神奇之处是，它是被一个函数返回的。要保证其正确执行，其所被创建时所引用的变量，也不能比销毁。相当于，把其执行环境
// “闭合包含”起来了。
// WENG, 19.12.28 1922



// 2.函数作为参数被传递
var max = 10,
    fn = function (x) {
        if (x > max) {
            console.log(x);
        }
    };

// 匿名函数
(function (f) {
    var max = 100;
    f(15);

})(fn);




// 关于原型和闭包，所引用的文章的作者有一个系列的讲解，咱不详细列出，只说明内涵吧：
// https://www.cnblogs.com/wangfupeng1988/p/3977924.html
// 1.JS中一切皆对象；
// 2.对象和函数的关系：对象是由函数创建的。
// 3.对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function。
// 你不知道它到底是一个object对象，还是数组，还是new Number等等。这个时候就需要用到instanceof。
// 4.访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。
// 5.在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。
// 因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。

